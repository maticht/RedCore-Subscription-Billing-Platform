# 1. Компоненты системы

Платформа подписочного биллинга построена на принципах микросервисной архитектуры. Ключевые компоненты обеспечивают четкое разделение ответственности:

- **API Gateway**  
  Единая точка входа. Маршрутизация, rate limiting, базовая аутентификация.

- **Auth Service**  
  Аутентификация (OAuth2), авторизация (RBAC), управление пользователями и Tenant ID.  
  *Стек данных: PostgreSQL, Redis

- **Subscription Service**  
  Управление жизненным циклом подписок (создание, продление, отмена, приостановка), логика тарифов (Plans).  
  Стек данных: PostgreSQL

- **Payment Service**  
  Обработка транзакций, вызов Адаптеров Провайдеров, расчет возвратов (Refunds).  
  Стек данных: PostgreSQL

- **Provider Adapters**  
  Инкапсуляция логики интеграции с внешними платежными системами (PayPal, Stripe и т.д.).

- **Webhook Handler**  
  Прием, валидация и первоначальная обработка асинхронных уведомлений от внешних провайдеров.  
  Стек данных: Kafka, Redis

- **Retry/Scheduler Service**  
  Планирование автоматических продлений и управление очередями повторных попыток (Retry) для неудавшихся платежей.  
  Стек данных: Kafka, PostgreSQL

- **Admin Portal UI**  
  Интерфейс для администраторов (управление тарифами, мониторинг операций, отчеты).  
  Интерфейс: REST API

- **Customer Portal UI**  
  Интерфейс для клиентов (управление подписками, оплата, просмотр истории).  
  Интерфейс: REST API

# 2. Архитектурная диаграмма (описание)

Архитектура имеет трехуровневую структуру: **Интерфейсы/Шлюз $\rightarrow$ Сервисы $\rightarrow$ Асинхронные системы/Хранилища.**

1.  Входящие запросы: Внешние запросы от B2B-партнеров и UI проходят через API Gateway, который перенаправляет их в соответствующие сервисы после проверки Auth Service.
2.  Асинхронная обработка: Для всех критически важных и ресурсоемких операций (автоматическое продление, ретраи, обработка вебхуков) используется **Apache Kafka** в качестве центрального брокера сообщений.
    * Retry/Scheduler Service помещает в Kafka события для списания или повторных попыток.
    * Webhook Handler помещает в Kafka сырые события от провайдеров для дальнейшей асинхронной обработки.
3.  Хранение: PostgreSQL используется как основное транзакционное хранилище (Source of Truth) для подписок, платежей и тарифов. Redis используется для кэширования, хранения сессий и обеспечения идемпотентности (например, хранение ключей идемпотентности).
4.  Мониторинг: Все компоненты отправляют метрики в Prometheus и логи в Loki. Grafana используется для визуализации дашбордов и алертов.

[Упрощенная Концептуальная архитектура.drawio.png](https://github.com/maticht/RedCore-Subscription-Billing-Platform/blob/main/imgs/%D0%9A%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%20%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.drawio.drawio.png)

[Концептуальная архитектура.drawio.png](https://github.com/maticht/RedCore-Subscription-Billing-Platform/blob/main/imgs/%D0%9A%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0.drawio.png)
# 3. Архитектурные принципы и паттерны

1.  Microservices Architecture: Разделение бизнес-логики на небольшие, независимые и автономные сервисы для улучшения поддерживаемости и масштабируемости.
2.  API-First Design: Все сервисы предоставляют свою функциональность через четко определенные REST API. UI/Порталы взаимодействуют с бэкендом исключительно через эти API.
3.  Event-Driven Architecture: Использование Apache Kafka для асинхронного взаимодействия
4.  Idempotency: Все критические операции (списание, возврат, обработка вебхуков) должны быть идемпотентными.
5.  Single Source of Truth: PostgreSQL выступает как единое надежное хранилище для всех транзакционных данных.

# 4. Схемы взаимодействия данных (Data Flow)

## 4.1 Поток создания подписки (Синхронный)

1.  B2B / Customer UI отправляет запрос на API Gateway.
2.  API Gateway $\rightarrow$ Auth Service (валидация).
3.  API Gateway $\rightarrow$ Subscription Service (создание записи `Subscription`).
4.  Subscription Service вызывает Payment Service для первого списания.
5.  Payment Service $\rightarrow$ Provider Adapters (взаимодействие с внешним провайдером).
6.  Provider Adapters возвращает результат $\rightarrow$ Payment Service $\rightarrow$ Subscription Service (обновление статуса).

[UML Поток создания подписки.png](https://github.com/maticht/RedCore-Subscription-Billing-Platform/blob/main/imgs/UML%20%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%20%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D0%BA%D0%B8.png)
## 4.1 Поток автоматического продления (Асинхронный)

1.  Retry/Scheduler Service читает из БД запланированные подписки и помещает сообщение (event) в Kafka Topic: `subscriptions.renew_required`**.
2.  Subscription Service потребляет event $\rightarrow$ запускает логику продления.
3.  Subscription Service вызывает Payment Service для списания.
4.  Если списание успешно, Subscription Service обновляет статус и срок подписки.
5.  Если списание неуспешно, Payment Service помещает сообщение о неудаче в Kfka Topic: `payments.failed`**.
6.  Retry/Scheduler Service потребляет это сообщение и планирует следующую попытку списания (согласно алгоритму retry).

[UML Поток автоматического продления.png](https://github.com/maticht/RedCore-Subscription-Billing-Platform/blob/main/imgs/UML%20%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%20%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%BE%D0%B4%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F.png)
# 5. Технологический стек и хранилища данных

- Основная БД: PostgreSQL  
  Роль: транзакционная, реляционная БД. Используется для хранения подписок, платежей, тарифов.

- Брокер сообщений: Apache Kafka  
  Роль: асинхронная коммуникация, очереди retry, event sourcing.

- Кэш/Идемпотентность: Redis  
  Роль: кэширование, сессии, хранение ключей идемпотентности, Rate Limiting.

- Логирование: Loki  
  Роль: сбор структурированных логов со всех микросервисов.

- Мониторинг: Prometheus + Grafana  
  Роль: сбор метрик, визуализация дашбордов, алерты (SLA, RPS).

- Хранение объектов: S3-совместимое хранилище  
  Роль: хранение отчетов, конфигураций, архивов (вне основного транзакционного потока).

# 6. Вопросы производительности и масштабирования️

1.  Горизонтальное масштабирование: Все микросервисы (кроме хранилищ) спроектированы как stateless (без состояния) и могут быть масштабированы путем добавления новых инстансов.
2.  Отказоустойчивость: Использование Kafka гарантирует, что даже при падении сервиса, все события будут сохранены и обработаны после восстановления.
3.  Оптимизация БД: Использование пулов соединений (Connection Pooling) и шардинга (при превышении определенного объема данных) для PostgreSQL.
4.  Обработка пиков: Асинхронная обработка через брокер сообщений позволяет системе принимать большое количество входящих запросов (>1000 RPS) и обрабатывать их с контролируемой нагрузкой на бэкенд-сервисы.