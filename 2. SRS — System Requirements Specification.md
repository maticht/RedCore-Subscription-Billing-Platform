# 1. Введение

## 1.1 Назначение документа
Документ описывает системные, функциональные и нефункциональные требования к платформе подписочного биллинга. Он предназначен для команды разработки, тестирования и эксплуатации, чтобы обеспечить:
- Полный жизненный цикл подписок
- Автоматические продления и обработку платежей
- Возвраты и интеграцию с внешними провайдерами
- Масштабируемость и стабильность при нагрузке >1000 RPS

## 1.2 Область применения системы
Система предназначена для:
- Управления подписками и тарифными планами
- Обработки платежей, возвратов и retry
- Интеграции с внешними платёжными системами (PayPal, Stripe, CUSTOM)
- Обеспечения UI для клиентов (Кабинет клиента) и администраторов (Кабинет администратора)
- Логирования, мониторинга и оповещений
- Масштабируемости и отказоустойчивости на основе брокера сообщений (Kafka)

## 1.3 Словарь терминов
- Subscription - подписка
- Plan - тарифный план
- Customer - клиент
- Payment - платеж
- Refund - возврат
- Provider - платёжный провайдер
- Webhook - уведомление от внешнего сервиса
- Tenant - арендатора / клиент multi-tenant
- RPS - запросов в секунду
- Retry - повторная попытка операции
- API - интерфейс взаимодействия

## 1.4 Ссылки
- [PCI DSS — Data Security Standard](https://www.pcisecuritystandards.org/standards/pci-dss/)  
- [OAuth 2.0 — The Authorization Framework (RFC 6749)](https://datatracker.ietf.org/doc/html/rfc6749)  
- [OAuth 2.0 Overview](https://oauth.net/2/)  
- [Kafka — документация Apache Kafka](https://kafka.apache.org/documentation/)  
- [Prometheus — Monitoring system & time series database](https://prometheus.io/)  
- [Grafana — Open source analytics & monitoring](https://grafana.com/)  
- [Loki — Logs aggregation system from Grafana Labs](https://grafana.com/oss/loki/)

## 1.5 Обзор документа
Документ описывает:
- Общие требования и функции системы
- Типы пользователей и сценарии использования
- Функциональные и нефункциональные требования
- Архитектуру, API и Kafka-интерфейсы
- План внедрения и интеграции

# 2. Общее описание

## 2.1 Контекст системы
Система представляет собой распределённую платформу подписочного биллинга с:
- Микросервисной архитектурой
- Асинхронным взаимодействием через Apache Kafka
- REST API для B2B интеграций
- Веб-интерфейсами для B2C клиентов и администраторов
- Интеграцией с внешними платёжными провайдерами
- Поддержкой мониторинга, логирования и алертинга

## 2.2 Высокоуровневые функции
- Управление подписками: создание, продление, приостановка, отмена
- Поддержка тарифных планов и триалов
- Автоматическое продление подписок
- Автоматический retry при ошибках списаний
- Обработка возвратов
- Приём и обработка Webhook событий от внешних провайдеров
- Кабинеты пользователей и администраторов
- Логирование и метрики всех ключевых операций
- Масштабируемость и отказоустойчивость

## 2.3 Типы пользователей
- B2C клиент - управляет своими подписками
- B2B партнёр - интегрируется через API
- Администратор - управляет пользователями, тарифами, мониторингом
- Интегратор / провайдер - взаимодействует через вебхуки и адаптеры

## 2.4 Среда эксплуатации
- Облачная инфраструктура
- PostgreSQL, Redis, S3
- Kafka как основной механизм коммуникации
- Kubernetes / контейнерная среда
- Поддержка multi-tenant
- Нагрузка >1000 RPS

## 2.5 Ограничения
- Идемпотентность всех API и Kafka-событий
- Время обработки вебхука ≤ 3 секунд
- Соответствие PCI DSS
- Ограничения форматов вебхуков от провайдеров

## 2.6 Допущения и зависимости
- Все провайдеры используют вебхуки
- Клиентские и административные UI используют REST API
- Асинхронная логика работает через Kafka
- Система развёрнута в облаке и масштабируется горизонтально

# 3. Функциональные возможности

## 3.1 Управление подписками
- Создание новой подписки
- Получение статуса подписки
- Изменение плана и параметров
- Приостановка и возобновление
- Отмена подписки
- Автоматическое и ручное продление

## 3.2 Обработка платежей
- Списания и возвраты
- Retry при ошибках платежа
- Автоматическая логика продлений
- Инициирование и обработка возвратов
- Интеграция с внешними провайдерами через адаптеры
- Асинхронная обработка событий

## 3.3 Интерфейсы
- Кабинет клиента для управления подписками и оплатой
- Кабинет администратора для мониторинга и управления
- Панели уведомлений и алертов
- Дашборды метрик и логирования

## 3.4 Модель данных

![[ERD.drawio.png]]


# 4. Внешние интерфейсы

## 4.1 UI требования
- REST API для B2B
- Веб-интерфейсы для клиентов и администраторов
- Адаптивная верстка
- Поддержка всех основных браузеров

## 4.2 External REST API (Commands → Kafka Events)

REST API используется **только для внешних клиентов (UI, B2B)**.  
Каждый REST-вызов создаёт **Kafka событие**, а все внутренние сервисы работают асинхронно.

Документация:  
- [4. API Specification](https://github.com/maticht/RedCore-Subscription-Billing-Platform/blob/main/4.%20API%20Specification.md)
- [5. Kafka Topics Specification](https://github.com/maticht/RedCore-Subscription-Billing-Platform/blob/main/5.%20Kafka%20Topics%20Specification.md)
### 4.2.1 Subscriptions API
- **POST /subscriptions**  
    Создание подписки (синхронная операция) 
    - Валидация данных 
    - Создание записи подписки в БД 
    - Инициация первого платежа через Payment Service 
    - Возврат результата клиенту
	После успешного создания порождает событие **`subscriptions.created`** (асинхронно, не блокирует ответ клиенту)
- **GET /subscriptions/{id}**  
    Получение состояния
- **PUT /subscriptions/{id}**  
    Обновление подписки  
    Порождает событие **`subscriptions.updated`**
- **DELETE /subscriptions/{id}**  
    Отмена подписки  
    Порождает событие **`subscriptions.cancelled`** 

### 4.2.2 Payments API
- **POST /payments**  
    Запросить платёж вручную  
    Порождает событие **`payments.requested`**
- **GET /payments/{id}**  
    Получение статуса
- **GET /payments**
    Получить список всех платежей
- **POST /payments/{id}/retry**  
    Ручной retry  
    Порождает событие **`payments.retry.requested`**

### 4.2.3 Webhooks API (от провайдеров)
- **POST /webhooks/{provider}**  
    Приём вебхука  
    Порождает событие **`webhooks.received
## 4.3 Hardware Interfaces
- Облачные серверы
- Балансировщики нагрузки

## 4.4 Software Interfaces
- PostgreSQL, Redis, S3
- Prometheus, Grafana, Loki
- Apache Kafka (основной транспорт событий)

## 4.5 Communications Interfaces
- HTTPS
- TLS 1.2+
- OAuth2 + JWT
- Webhooks от платёжных провайдеров

# 5. Нефункциональные требования

## 5.1 Производительность
- Среднее время ответа API ≤ 300 мс
- Поддержка >1000 RPS
- Вебхуки: 500–800 событий в секунду

## 5.2 Безопасность
- OAuth2 и RBAC
- Соответствие PCI DSS
- HTTPS и TLS 1.2+
- Логирование всех критических событий

## 5.3 Надёжность
- Идемпотентность всех операций
- Retry механизм для failed payments
- Доступность 99.9%
- Автоматическое масштабирование и отказоустойчивость

## 5.4 Поддерживаемость
- Микросервисная архитектура
- Документированное API
- Логирование и мониторинг для диагностики

## 5.5 Масштабируемость
- Горизонтальное масштабирование сервисов
- Брокер сообщений для асинхронной обработки и очередей retry
- Поддержка тысяч подписок и клиентов

# 6. Прочие требования
- Multi-tenant поддержка B2B клиентов
- Настройка уведомлений и алертов
- Дашборды для администраторов
- Внешние интеграции через адаптеры

## 7. План тестирования и обеспечение качества (QA)

### 7.1 Стратегия тестирования

- ##### Unit Testing (Модульное тестирование)
    - Цель: Проверить **изолированную бизнес-логику** на уровне отдельных функций, методов или классов
    - Фокус: Расчеты (например, расчет скидки), валидация данных (например, валидация даты), работа с небольшими блоками кода
    - Ответственный: Разработка
    
- ##### Integration Testing (Интеграционное тестирование)
    - Цель: Проверить корректность **взаимодействия** между различными модулями или сервисами
    - Фокус: Взаимодействие микросервисов (Subscription Service и Payment Service), а также внешняя интеграция (Provider Adapters) с заглушками внешних систем
    - Ответственный: Разработка, QA
    
- ##### End-to-End (E2E) Testing (Сквозное тестирование)
    - Цель: Проверить весь сквозной бизнес-процесс от начала до конца, имитируя действия реального пользователя
    - Фокус: Полный сценарий, например: создание подписки через UI $\rightarrow$ инициирование списания $\rightarrow$ обработка вебхука
    - Ответственный: QA
    
- ##### Non-Functional Testing (Нефункциональное тестирование)
    - Цель: Проверить, что система соответствует требованиям качества и ограничениям, описанным в разделе 5 (Производительность, Безопасность, Надежность)
    - Фокус: Нагрузочное тестирование (1000+ RPS), тестирование отказоустойчивости (Failover), тестирование безопасности (PCI DSS), тестирование изоляции данных (Multi-tenant)
    - Ответственный: QA, DevOps
### 7.2 Виды тестирования

#### 7.2.1 Тестирование производительности (Performance Testing)
- Load Testing (Нагрузочное): Подтвердить способность системы обрабатывать заявленную нагрузку >1000 RPS при среднем времени ответа < 300 мс
- Stress Testing (Стрессовое): Определить точку отказа системы при экстремальной нагрузке (например, при 1500 RPS) для оценки пределов масштабируемости

#### 7.2.2 Тестирование отказоустойчивости (Reliability Testing)
- Failover Testing: Проверка корректности работы механизма Retry и Kafka-топиков при падении одного из сервисов (например, Payment Service). Убедиться, что события не теряются
- Idempotency Testing: Проверка, что повторное получение одного и того же Kafka-сообщения (особенно для платежей, возвратов и вебхуков) не приводит к дублированию транзакций в базе данных

#### 7.2.3 Тестирование безопасности (Security Testing)
- Authentication/Authorization Testing (Тестирование прав): Подтвердить, что B2C Клиент не может получить доступ к данным других клиентов или тарифам Администратора (RBAC)
- PCI DSS Compliance Check: Проверка, что все данные платежных карт обрабатываются вне системы (внешними провайдерами) и что внутренние логи не содержат конфиденциальной платежной информации
- Input Validation: Проверка защиты от XSS/SQL Injection в API Gateway и всех формах UI

#### 7.2.4 Тестирование Multi-tenant
- Data Isolation Testing: Проверка, что Tenant A не имеет никакого доступа к данным (подписки, клиенты, платежи) Tenant B (критически важно для `Customer Service`)