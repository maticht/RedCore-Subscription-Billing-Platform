# Use Case: Manual Retry платежа (UC-RETRY-01)

**Название:** Ручной запуск retry для failed payment  
**ID:** UC-RETRY-01  
**Связанные User Story:** US-5.2, US-2.3

## Краткое описание
Администратор вручную инициирует повторную попытку списания по неуспешному платёжному запросу. Система создаёт задачу retry, публикует событие и отслеживает результат. Весь процесс логируется и доступен для аудита

## Primary actor
Администратор (role: admin)

## Supporting actors
Retry Service, Payment Service, Provider Adapter, Kafka, UI (Admin Panel), Audit Log

## Предусловия
- Пользователь админ аутентифицирован и авторизован (роль admin)  
- Платёж существует в БД со статусом `failed` (не permanent)  
- attempts_count < max_retries (если = max_retries кнопка не показывается)  
- Система доступна и имеет соединение с Kafka и Retry Service

## Триггер
Админ открывает карточку failed payment и нажимает "Запустить retry"

## Основной (счастливый) сценарий
1. Админ открывает Admin UI и переходит в раздел "Ошибки платежей"  
2. Админ выбирает платеж с status = `failed` и attempts_count < max_retries  
3. UI отображает кнопку "Запустить retry" и при клике показывает подтверждение с payment_id и предупреждением о возможном повторном списании  
4. Админ подтверждает действие  
5. UI вызывает API: `POST /admin/payments/{payment_id}/retry` (Authorization: Bearer token, admin)  
6. API валидирует права, проверяет current status, attempts_count, idempotency и возвращает 202 Accepted с task_id  
7. API публикует в Kafka событие `payments.retry.manual` с payload { payment_id, admin_id, attempt_triggered_at, attempt_number_expected }  
8. Retry Service потребляет событие, создаёт internal retry-task и ставит её в очередь выполнения  
9. Retry Service вызывает Payment Service / Provider Adapter для выполнения списания (асинхронная попытка)  
10. Получен успешный ответ от провайдера:
11. Payment Service обновляет запись payment → status = `succeeded`, attempts_count++  
12. Публикуется событие `payments.succeeded`  
13. UI получает обновление (websocket/poll) и показывает уведомление "Платёж успешно проведён"  
14. Audit Log записывает: admin_id, payment_id, task_id, attempt_number, result = success, timestamp  

## Альтернативный сценарий
_(Ветвление от шага **10** основного сценария, когда получен ответ от провайдера)_
1. На шаге 10 основного сценария вместо успешного ответа провайдер возвращает временную ошибку (transient error).
2. При неуспешном ответе провайдера (временная ошибка):
3. Payment Service увеличивает attempts_count, возможно устанавливает next_attempt_time согласно retry policy  
4. Если attempts_count < max_retries публикуется `payments.retry.requested` и статус остаётся `failed` (или `retrying`)  
5. Если attempts_count reached max_retries статус = `failed_permanent` и публикуется `payments.failed_permanent`  
6. UI обновляет карточку и показывает текущее состояние  
7. Audit Log фиксирует результат и сообщение провайдера

## Исключения / Extensions
- **E1: Недостаточно прав**
  1. При шаге 6 API возвращает 403 Forbidden и не публикует событие
  2. UI показывает ошибку доступа

- **E2: Платёж уже в succeeded или failed_permanent**
  1. При шаге 6 API возвращает 409 Conflict с пояснением и не создаёт задачу
  2. UI показывает сообщение "Retry невозможен для текущего статуса"

- **E3: Idempotency / повторный клик**
  1. Если админ случайно нажал retry несколько раз, API проверяет idempotency (Idempotency-Key) или task_id и возвращает существующий task_id без создания новой задачи
  2. Audit Log фиксирует повторную попытку запуска от того же admin_id

- **E4: Сбой коммуникации с Retry Service / Kafka**
  1. При проблемах публикации API возвращает 502/503 и сохраняет временную заявку в локальном queue для повторной отправки
  2. UI показывает сообщение "Ошибка, retry отложен"

- **E5: Провайдер ответил permanent failure**
  1. Payment Service помечает payment = `failed_permanent`, публикует `payments.failed_permanent`, UI уведомляет админа

## Постусловия
- Если успешный retry: payment.status = `succeeded`, attempts_count увеличен, события опубликованы, audit записан  
- Если неуспешный retry и превышен лимит: payment.status = `failed_permanent`, события опубликованы, audit записан  
- UI и админ-панель отражают актуальное состояние

## Бизнес-правила
- max_retries - configurable (например 5)  
- Экспоненциальный backoff: delay = base_delay * 2^(attempt_number - 1) при автоматических retry, ручной retry инициирует immediate attempt но учитывает rate limits провайдера  
- Все retry операции идемпотентны (ключи по payment_id + attempt_number)  
- Audit записывается для каждого ручного действия (admin_id обязательное поле)

## API / Events / DB изменения (техническая часть)
- API Endpoint: `POST /admin/payments/{payment_id}/retry`  
  - Request: { idempotency_key (optional) }  
  - Response: 202 Accepted { task_id } или 4xx/5xx  
- Kafka events:
  - `payments.retry.manual` { payment_id, admin_id, task_id, attempt_number_requested, timestamp }  
  - `payments.retry.requested` (используется Retry Service для планирования)  
  - `payments.succeeded` / `payments.failed_permanent`  
- DB changes:
  - payments.attempts_count++  
  - payments.status может стать `retrying` / `succeeded` / `failed_permanent`  
  - Audit table: { admin_id, payment_id, task_id, attempt_number, result, provider_msg, timestamp }

## UI / UX требования
- На карточке платежа показывать: payment_id, amount, status, attempts_count, last_attempt_time, provider_message, кнопку Retry если allowed  
- Подтверждение перед запуском с показом payment_id и предупреждением о возможном повторном списании  
- Показ прогресса: "retrying..." пока задача выполняется  
- Чёткие ошибки (403, 409, 502) с понятными текстами для админа

## Нефункциональные требования
- Время отклика API для старта manual retry ≤ 300 ms (возврат 202)  
- Система должна логировать все retry операции для аудита и соответствия требованиям PCI  
- Метрики:
  - `manual_retry_requests_total`  
  - `manual_retry_success_total`  
  - `manual_retry_failure_total`  
  - `retry_latency_seconds`  

## Тест-кейсы (кратко)
- TC-01: Успешный ручной retry - payment переходит в succeeded, события созданы, audit записан  
- TC-02: Ручной retry при max_retries - кнопка недоступна, 409 при попытке  
- TC-03: Повторный клик - idempotent behaviour, создаётся одна задача  
- TC-04: Пользователь без прав - 403 и отсутствие изменений  
- TC-05: Provider отвечает permanent error - payment -> failed_permanent, событие опубликовано

## Замечания для разработчиков
- Использовать transactional updates для attempts_count и status, чтобы избежать race conditions  
- При публикации событий в Kafka подтверждать delivery (гарантировать at-least-once) и обрабатывать возможные дубликаты идемпотентно  
- Обеспечить retry-safe обработчики (idempotency keys + dedupe в Redis если нужно)

## Замечания для QA
- Проверять на интеграционном стенде с моками провайдера сценарии success / transient_error / permanent_error  
- Проверить корректность audit-записей и содержимого Kafka-событий  
- Нагрузочное тестирование для ручных retry не требуется, но проверить, что массовые ручные retries не приводят к пересечению rate limits провайдера

